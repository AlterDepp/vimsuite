" Setzen des Runtimepath, in dem die Vimfiles gesucht werden:
let runtimepath_orig = &runtimepath
let &runtimepath = ''

" zuerst in vimsuite suchen
let &runtimepath = &runtimepath . ',' . g:vimfiles
let &runtimepath = &runtimepath . ',' . g:vimsuite . '/vimfiles'
"let &runtimepath = &runtimepath . ',' . g:vimsuite . '/vimfiles.latex'
let &runtimepath = &runtimepath . ',' . g:vimsuite . '/vimfiles.damos'

" dann in vim Installation suchen
let &runtimepath = &runtimepath . ',' . runtimepath_orig

" dann in vimsuite/after suchen
let &runtimepath = &runtimepath . ',' . g:vimfiles . '/after'
let &runtimepath = &runtimepath . ',' . g:vimsuite . '/vimfiles/after'
let &runtimepath = &runtimepath . ',' . g:vimsuite . '/vimfiles.latex/after'
let &runtimepath = &runtimepath . ',' . g:vimsuite . '/vimfiles.damos/after'
let &runtimepath = &runtimepath . ',' . g:vimsuite . '/vimfiles.stefan/after'

" Laden weiterer Einstellungen:
if (has("win32") || has("win64"))
    let g:os ='dos'
    execute 'source ' . expand(g:vimfiles . '/vimrc.dos')
else
    let g:os = 'linux'
    execute 'source ' . expand(g:vimfiles . '/vimrc.linux')
endif

if !exists('nobmsk')
    execute 'source ' . expand(g:vimfiles . '/vimrc.bmsk')
endif

" global settings
" ---------------
" Use Vim settings, rather then Vi settings (much better!).
" This must be first, because it changes other options as a side effect.
set nocompatible
set nobackup            " keep no backup file
set history=50          " keep 50 lines of command line history
set ruler               " show the cursor position all the time
set showcmd             " display incomplete commands

" filetype detection
filetype on
filetype plugin on
filetype plugin indent on
"syntax highlighing
"syntax on
syntax enable

" no syntax highliting when printing
set printoptions+=syntax:n

"highlite search
set incsearch
set hlsearch

" set global option for substitute
set gdefault
" case sensitive search
set noignorecase

" set very intelligent formatting
set formatoptions=croqwan2

" --------
" Changing
" --------
" Don't use Ex mode, use Q for formatting
"map Q gq

" overwrite selected text
vnoremap p s<C-R>0<ESC>
vnoremap P s<C-R>0<ESC>

" list tags
inoremap <C-T> <ESC>:tselect /^<C-R><C-W><CR>

" search for visual block
vnoremap <silent> g/ y/\V<C-R>=substitute(escape(@@,"/\\"),"\n","\\\\n","ge")<CR><CR>
vnoremap <silent> g? y?\V<C-R>=substitute(escape(@@,"?\\"),"\n","\\\\n","ge")<CR><CR>

" -------
" Display
" -------
" switchbuffer: use open window, split if new
"set switchbuf=useopen,split
set switchbuf=useopen
" wrap long lines
set wrap
" show line-numbers
set number
" show title
set title
" show matching bracket
set showmatch
" matchtime in 1/10 seconds
set matchtime=5
" show wrapped line
set showbreak=-->
" show position of cursor
set ruler
" show incomplete command
set showcmd
" match braces
"nnoremap g4 /[\(\{\[]<CR>:nohls<CR>v%o
"vnoremap g4 vg4

" set textwidth to 78
set textwidth=78

" special characters
" list special characters
set list
" special characters:
set listchars=eol:$,tab:>\ ,trail:_,extends:°,precedes:°
" special characters for keywords
" set iskeyword+=

" horizontal scrollbar in diff-mode
if &diff
    set guioptions+=b
endif

" ------
" Moving
" ------
" scrollwith at ^U and ^D
set scroll=5
" lines around the cursor
set scrolloff=10
" wrap line at (b=<BS>, s=<space>, h, l, <, >, [, ])
set whichwrap=
" backspace deletes: (indent,eol,start)
set backspace=indent,start
" find word under cursor
nnoremap + /<C-R><C-W><CR>
" mark word under cursor
nnoremap gm :let @/ = "<C-R><C-W>"<CR>:set hlsearch<CR>
" go to tag under cursor
nnoremap <TAB> g<C-]>
"nnoremap <CR> g<C-]>
nnoremap <CR> :tag <C-R><C-W><CR>
" return to previous position
nnoremap <S-TAB> <C-T>
nnoremap <BS> <C-T>
nnoremap <S-CR> <C-T>
" find next error
nnoremap <C-N> :cn<CR>
" go back to previous edited file
nnoremap gb :call GotoLastFile()<CR>

" -----------
" come and go
" -----------
set sessionoptions=blank,buffers,curdir,folds,help,resize,tabpages,winsize
" open window size
if &diff
    autocmd GUIEnter * set lines=60 columns=200
else
    autocmd GUIEnter * set lines=60 columns=100
endif
" read and write files automatically
set autoread
set autowrite
set autowriteall
" keep original files for these filetypes
set patchmode=
" jump to '" when reading a file
"autocmd BufEnter *
"autocmd BufReadPost *
"       \ if line("'\"") > 0 && line("'\"") <= line("$") |
"       \       execute "normal g'\"" |
"       \ endif

" set nomodifiable on writeprotected files
autocmd BufReadPost *
            \ if &readonly == 1 |
            \       execute ':set nomodifiable' |
            \ else |
            \       execute ':set modifiable' |
            \ endif
" read all files on got of focus
" autocmd FocusGained * execute
" save all files on loss of focus
autocmd FocusLost * execute ':wa'
" since we always save, don't use a swapfile
set noswapfile

" -----------
" spell check
" -----------
set spelllang=de
set spellfile=$VIM/myspell.add
let &spellfile=&spellfile . ',' . g:vimfiles . '/spell/bmsk.add'

if exists('g:debug')
    if (g:debug > 0)
        echo 'loaded vimrc'
    endif
endif

" ----------
" Completion
" ----------
set completeopt=longest,menuone
inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"
inoremap <expr> <C-n> pumvisible() ? '<C-n>' :
  \ '<C-n><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'
inoremap <expr> <M-,> pumvisible() ? '<C-n>' :
  \ '<C-x><C-o><C-n><C-p><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'


" --------------
" DoxygenToolkit
" --------------
let g:DoxygenToolkit_commandTag             = "\\"
"let g:DoxygenToolkit_authorName            = "Stefan Liebl"

let g:DoxygenToolkit_briefTag_pre          = g:DoxygenToolkit_commandTag . "brief    "
"let g:DoxygenToolkit_briefTag_post         = ""
let g:DoxygenToolkit_paramTag_pre          = g:DoxygenToolkit_commandTag . "param    "
"let g:DoxygenToolkit_paramTag_post         = " "
let g:DoxygenToolkit_returnTag             = g:DoxygenToolkit_commandTag . "return   "
"let g:DoxygenToolkit_blockHeader           = ""
"let g:DoxygenToolkit_blockFooter           = ""
"let g:DoxygenToolkit_licenseTag            = s:licenseTag
let g:DoxygenToolkit_fileTag               = g:DoxygenToolkit_commandTag . "file     "
let g:DoxygenToolkit_authorTag             = g:DoxygenToolkit_commandTag . "author   "
let g:DoxygenToolkit_dateTag               = g:DoxygenToolkit_commandTag . "date     "
let g:DoxygenToolkit_dateFormat            = "%d.%m.%Y"
"let g:DoxygenToolkit_undocTag              = "DOX_SKIP_BLOCK"
let g:DoxygenToolkit_blockTag              = g:DoxygenToolkit_commandTag . "name     "
let g:DoxygenToolkit_classTag              = g:DoxygenToolkit_commandTag . "class    "
"let g:DoxygenToolkit_cinoptions            = "c1C1"
let g:DoxygenToolkit_startCommentTag       = "/****************************************************************//*!"

let g:DoxygenToolkit_startCommentBlock     = "/*! "
"let g:DoxygenToolkit_interCommentTag       = "* "
let g:DoxygenToolkit_endCommentTag         = "********************************************************************/"
"let g:DoxygenToolkit_endCommentBlock       = " */"
let g:DoxygenToolkit_descriptionTag        = "Beschreibung"
let g:DoxygenToolkit_attentionTag          = g:DoxygenToolkit_commandTag . "attention "
let g:DoxygenToolkit_saTag                 = g:DoxygenToolkit_commandTag . "sa        "

"let g:DoxygenToolkit_ignoreForReturn       = "inline static virtual void"

" Maximum number of lines to check for function parameters
"let g:DoxygenToolkit_maxFunctionProtoLines = 10

" Add name of function after pre brief tag if you want
"let g:DoxygenToolkit_briefTag_funcName     = "no"

" Add description to DoxAuthor if you want
let g:DoxygenToolkit_author_description = "yes"

" Add description to Dox if you want
let g:DoxygenToolkit_dox_description = "yes"

" Add attention to Dox if you want
let g:DoxygenToolkit_dox_attention = "yes"

" Add sa to Dox if you want
let g:DoxygenToolkit_dox_sa = "yes"

" -----------
" VCS Command
" -----------
let g:VCSCommandMenuRoot = '&VCS'

